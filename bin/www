#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('bvkpitch-backend:server');
var http = require('http');
const socketIO = require("socket.io");
const Users = require("../postgres/User");
const Address = require("../postgres/Address");
const fs = require("fs");
const fetch = require("node-fetch");
const Macro = require("../postgres/Macro");
const Micro = require("../postgres/Micro");
const Compareable_Offers = require("../postgres/Compareable-Offers");
const MLP_Location = require("../postgres/MLP_Location");
const MLP_Unit = require("../postgres/MLP_Unit");
const Market = require("../postgres/Market");
const jwt = require('jsonwebtoken');
const crypto = require("crypto");
const Seat = require("../postgres/Seat");
const SearchTracker = require("../postgres/SearchTracker");
const UserSeatTracker = require("../postgres/UserSeatTracker");
const {where} = require("sequelize/types");

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

const io = socketIO(server,{
  cors: {
      origin: '*'
    }
})

const searchIO = io.of('/search')

searchIO.use((socket, next) => {
    if (socket.handshake.query && socket.handshake.query.token){
        jwt.verify(socket.handshake.query.token, 'SECRET_KEY', (err, decoded) => {
            if (err) {
                return next(new Error('Authentication error'))
            }
            socket.decoded = decoded
            next()
        })
    }
    else {
        next(new Error('Authentication error'))
    }
})

const getHashedPassword = (password) => {
    const sha256 = crypto.createHash('sha256')
    return sha256.update(password).digest('base64')
}

searchIO.on('connection', (socket) => {

    socket.on('testConn', async (id, socketid, cat) => {
        const results = await Users.findOne({where:{id: id}})
        let seats = null
        if(results !== null){
            seats = await Seat.findOne({where: {id: results.dataValues.last_seatplace}})
        }
        if(seats !== null){
            if(seats.dataValues.is_free){
                if(cat === 'search'){
                    await Users.update({socket_search: socketid, seatplace: results.dataValues.last_seatplace}, {where: {id: id}})
                    await UserSeatTracker.create({user_id: id, seatplace: results.dataValues.last_seatplace, logged_in: Date.now(), user_socket:socketid})
                    await Seat.update({is_free: false}, {where: {id: results.dataValues.last_seatplace}})
                }
            }else {
                if(cat === 'search'){
                    await Users.update({socket_search: socketid}, {where: {id: id}})
                    socket.emit('needSeat')
                }
            }
        }else {
            if(cat === 'search'){
                await Users.update({socket_search: socketid}, {where: {id: id}})
                socket.emit('needSeat')
            }
        }
    })

    socket.on('search', async (selectedAddress, makroArray, mikroArray, id) => {
        const [AddressData, MacroDataArray, MicroDataArray]  = await setAddress(selectedAddress, makroArray, mikroArray, id)
        const CompareOffersArray = await setCompareOffers(selectedAddress, id)
        const MarketData = await setMarketYield(selectedAddress, id)
        const MLPLocationData = await setMLPLocation(selectedAddress, id)
        const MLPUnitData = await setMLPUnit(selectedAddress, id)
        const sockert = await Users.findOne({where: {id: id}})
        const seatplace = await Seat.findOne({where:{id: sockert.dataValues.seatplace}})
        await test(seatplace.dataValues.socket, AddressData, CompareOffersArray, MacroDataArray, MicroDataArray, MLPLocationData, MLPUnitData, MarketData)
        await done(socket, sockert)
    })

    socket.on('disconnecting', async () => {
        const dcUser = await Users.findOne({where: {socket_search: socket.id}})
        if(dcUser !== null){
            await Users.update({last_seatplace: dcUser.dataValues.seatplace, seatplace: null}, {where: {id: dcUser.dataValues.id}})
            await UserSeatTracker.update({logged_out: Date.now()}, {where:{user_socket:dcUser.dataValues.socket_search}})
            await Seat.update({is_free: true}, {where:{id: dcUser.dataValues.seatplace}})
        }
        // console.log('User disconnected', socket.id)
    })
})

const test = async (seatplace, AddressData, CompareOffersArray, MacroDataArray, MicroDataArray, MLPLocationData, MLPUnitData, MarketData) => {
    await analysisSocket.to(seatplace).emit('init', {AddressData, CompareOffersArray, MacroDataArray, MicroDataArray, MLPLocationData, MLPUnitData, MarketData})
}

let analysisSocket

io.on("connection", (socket) => {
  // console.log("New client connected" + socket.id);

    analysisSocket = socket

    socket.on('login', async (username, password) => {
        const hashed_password = getHashedPassword(password)
        if (username && hashed_password) {
            const results = await Users.findOne({where:{username: username}})
            if (results.dataValues !== null) {
                if(results.dataValues.password !== hashed_password){
                    return socket.emit('auth', {auth: false, token: false, result: 'Incorrect Username or Password. Try again!'})
                }
                const id = results.dataValues.id
                const token = jwt.sign({id}, 'SECRET_KEY', {
                    expiresIn: 1200,
                })
                // request.session.user = results
                await Users.update({seatplace: results.dataValues.last_seatplace}, {where: {id: results.dataValues.id}})

                // const userSeatResult = await UserSeatTracker.create({user_id: id, seatplace: results.dataValues.last_seatplace, logged_in: new Date.now()})

                socket.emit('auth', {auth: true, token: token, result: results.dataValues})
            } else {
                socket.emit('auth', {auth: false, token: false, result: 'Incorrect Username or Password. Try again!'})
            }
        } else {
            socket.emit('auth', {auth: false, token: false, result: 'no user exists'})
        }
    })

    socket.on('init', async (id, sid, cat) => {
        if(cat === 'analyse'){
            const seatRes = await Seat.findOne({where:{socket: id}})
            if(seatRes !== null){
                const location = id.slice(0,3)
                await Seat.upsert({socket: sid, id: id, is_free: seatRes.dataValues.is_free, location: location})
            }else {
                const location = id.slice(0,3)
                await Seat.upsert({socket: sid, id: id, is_free: true, location: location})
            }
        }
        const userData = await Users.findOne({where:{seatplace:id}})
        if(userData !== null){
            socket.emit('init', await returnDBData(userData.dataValues.id))
        }

    })

    socket.on('getTime', () => {
        returnDate(socket)
    })

    socket.on('disconnecting', async () => {
        const dcSeat = await Seat.findOne({where:{socket: socket.id}})
        if(dcSeat !== null){
            const user = await Users.findOne({where:{seatplace: dcSeat.dataValues.id}})
            if(user !== null){
                await Users.update({seatplace: null}, {where: {id: user.dataValues.id}})
            }
            if(dcSeat.location !== 'ber'){
                await Users.update({last_seatplace: null}, {where:{id:user.dataValues.id}})
            }
            await Seat.destroy({where: {socket: socket.id}})
        }
    })
  // socket on address update
  // fetch api 21 re safe to database
  // get data from Database and emit it to id
})

async function done(socket, sockert){
    let test = false
    socket.emit('searchComplete', test)
}

function returnDate(socket) {
    setTimeout(function (){
        const date = new Date().toLocaleString()
        socket.emit('setTime', date)
        returnDate(socket)
    }, 5000)
}

async function setAddress(selectedAddress, makroArray, mikroArray, id){
    const res = await fetch('https://api.21re.de/v3/scores', {
        method: 'POST',
        headers: {
            'accept': 'application/json',
            'content-type': 'application/json',
            'authorization': 'Bearer J5P9OA6Q9LDDTG0EA10B6S8NU1CQ6J7K9G8TE9D6RLJ4042Q2GAJR37F',
            'Content-Type': 'application/json; charset=UTF-8'
        },
        body: JSON.stringify({
            "address": {
                "country": `${selectedAddress.context[3].short_code.toUpperCase()}`,
                "locality": `${selectedAddress.context[2].text}`,
                "postalCode": `${selectedAddress.context[0].text}`,
                "route": `${selectedAddress.text}`,
                "streetNumber": `${selectedAddress.address}`,
                "location": {"lat": selectedAddress.center[1], "lng": selectedAddress.center[0]},
            },
            "macro": [`${makroArray[0].name}`, `${makroArray[1].name}`, `${makroArray[2].name}`, `${makroArray[3].name}`],
            "micro": [`${mikroArray[0].name}`, `${mikroArray[1].name}`, `${mikroArray[2].name}`, `${mikroArray[3].name}`]
        })
    })
    if(res.status === 200){
        const data = await res.json()

        const dataToUpdate = {
            user_id: id,
            postal_code: data.address.postalCode,
            locality: data.address.locality,
            route: data.address.route,
            street_number: data.address.streetNumber,
            loc_lat: data.address.location.lat,
            loc_lng: data.address.location.lng
        }

        const trackerData = {
            user_id: id,
            postal_code: data.address.postalCode,
            locality: data.address.locality,
            route: data.address.route,
            street_number: data.address.streetNumber,
            loc_lat: data.address.location.lat,
            loc_lng: data.address.location.lng,
            date: new Date().toISOString()
        }

        const tracker = await SearchTracker.create(trackerData)
        const [address, created] = await Address.upsert(dataToUpdate)

        const final = address.dataValues

        let MacroArray = []
        let MicroArray = []

        await Macro.destroy({
            where: {user_id: id}
        })

        await Micro.destroy({
            where: {user_id: id}
        })

        await makroArray.map( async (e) => {
            const macro = await Macro.create({user_id: id, name: e.de, score: data.macro[e.name].score})
            MacroArray.push(macro.dataValues)
        })

        await mikroArray.map( async (e) => {
            const micro = await Micro.create({user_id: id, name: e.de, score: data.micro[e.name].score})
            MicroArray.push(micro.dataValues)
        })

        return [final , MacroArray, MicroArray]
    }
}

async function setCompareOffers(selectedAddress, id){
    const res = await fetch('https://api.21re.de/v3/comparables/query', {
        method: 'POST',
        headers: {
            'accept': 'application/json',
            'content-type': 'application/json',
            'authorization': 'Bearer J5P9OA6Q9LDDTG0EA10B6S8NU1CQ6J7K9G8TE9D6RLJ4042Q2GAJR37F',
            'Content-Type': 'application/json; charset=UTF-8'
        },
        body: JSON.stringify({
            "address": {
                "country": `${selectedAddress.context[3].short_code.toUpperCase()}`,
                "locality": `${selectedAddress.context[2].text}`,
                "postalCode": `${selectedAddress.context[0].text}`,
                "route": `${selectedAddress.text}`,
                "streetNumber": `${selectedAddress.address}`,
                "location": {"lat": selectedAddress.center[1], "lng": selectedAddress.center[0]},
            },
            "radius": 50000,
            "offerType": "rent",
            "objectType": "apartment",
            "area": {"from": 40, "to": 90},
            "year": {"from": 1980, "to": 2050},
            "rooms": {"from": 2, "to": 5},
            "offerDate": {"from": {"year": 2019, "quarter": 1}, "to": {"year": 2050, "quarter": 4}}
        })
    })
    if(res.status === 200){
        let compareableOffersArray = []
        const data = await res.json()

        await Compareable_Offers.destroy({
            where: {user_id: id}
        })
        data.items.map(async (e) => {
            const dataToUpdate = {
                user_id: id,
                offer_date: e.offerDate,
                sqm_price_cents: e.sqmPriceCents,
                build_year: e.buildYear,
                area: e.area,
                rooms: e.rooms,
                route: e.route,
                street_number: e.streetNumber
            }
            const res = await Compareable_Offers.create(dataToUpdate)
            compareableOffersArray.push(res.dataValues)
        })
        return compareableOffersArray
    }
}

async function setMarketYield(selectedAddress, id){
    const res = await fetch('https://api.21re.de/v3/yields/query', {
        method: 'POST',
        headers: {
            'accept': 'application/json',
            'content-type': 'application/json',
            'authorization': 'Bearer J5P9OA6Q9LDDTG0EA10B6S8NU1CQ6J7K9G8TE9D6RLJ4042Q2GAJR37F',
            'Content-Type': 'application/json; charset=UTF-8'
        },
        body: JSON.stringify({
            "address": {
                "country": `${selectedAddress.context[3].short_code.toUpperCase()}`,
                "locality": `${selectedAddress.context[2].text}`,
                "postalCode": `${selectedAddress.context[0].text}`,
                "route": `${selectedAddress.text}`,
                "streetNumber": `${selectedAddress.address}`,
                "location": {"lat": selectedAddress.center[1], "lng": selectedAddress.center[0]},
            }
        })
    })
    if(res.status === 200){
        const data = await res.json()

            const dataToUpdate = {
                user_id: id,
                office_city_top_min: data['office']['cityTop'].min,
                office_city_top_max: data['office']['cityTop'].max,
                office_city_top_avg: data['office']['cityTop'].avg,
                office_city_min: data['office']['city'].min,
                office_city_max: data['office']['cityTop'].max,
                office_city_avg: data['office']['city'].avg,
                office_neighborhood_min: data['office']['neighborhood'].min,
                office_neighborhood_max: data['office']['neighborhood'].max,
                office_neighborhood_avg: data['office']['neighborhood'].avg,
                retail_city_top_min: data['retail']['cityTop'].min,
                retail_city_top_max: data['retail']['cityTop'].max,
                retail_city_top_avg: data['retail']['cityTop'].avg,
                retail_city_min: data['retail']['city'].min,
                retail_city_max: data['retail']['city'].max,
                retail_city_avg: data['retail']['city'].avg,
                retail_neighborhood_min: data['retail']['neighborhood'].min,
                retail_neighborhood_max: data['retail']['neighborhood'].max,
                retail_neighborhood_avg: data['retail']['neighborhood'].avg,
                residential_city_top_min: data['residential']['cityTop'].min,
                residential_city_top_max: data['residential']['cityTop'].max,
                residential_city_top_avg: data['residential']['cityTop'].avg,
                residential_city_min: data['residential']['city'].min,
                residential_city_max: data['residential']['city'].max,
                residential_city_avg: data['residential']['city'].avg,
                residential_neighborhood_min: data['residential']['neighborhood'].min,
                residential_neighborhood_max: data['residential']['neighborhood'].max,
                residential_neighborhood_avg: data['residential']['neighborhood'].avg,
            }
            const [market, created] = await Market.upsert(dataToUpdate)
            return market.dataValues
        }
    if(res.status === 400){
        const dataToUpdate = {
            user_id: id,
            office_city_top_min: null,
            office_city_top_max: null,
            office_city_top_avg: null,
            office_city_min: null,
            office_city_max: null,
            office_city_avg: null,
            office_neighborhood_min: null,
            office_neighborhood_max: null,
            office_neighborhood_avg: null,
            retail_city_top_min: null,
            retail_city_top_max: null,
            retail_city_top_avg: null,
            retail_city_min: null,
            retail_city_max: null,
            retail_city_avg: null,
            retail_neighborhood_min: null,
            retail_neighborhood_max: null,
            retail_neighborhood_avg: null,
            residential_city_top_min: null,
            residential_city_top_max: null,
            residential_city_top_avg: null,
            residential_city_min: null,
            residential_city_max: null,
            residential_city_avg: null,
            residential_neighborhood_min: null,
            residential_neighborhood_max: null,
            residential_neighborhood_avg: null,
        }
        const [market, created] = await Market.upsert(dataToUpdate)
        return market.dataValues
    }
}

async function setMLPLocation(selectedAddress, id) {
    const res = await fetch('https://api.21re.de/v3/prices/location', {
        method: 'POST',
        headers: {
            'accept': 'application/json',
            'content-type': 'application/json',
            'authorization': 'Bearer J5P9OA6Q9LDDTG0EA10B6S8NU1CQ6J7K9G8TE9D6RLJ4042Q2GAJR37F',
            'Content-Type': 'application/json; charset=UTF-8'
        },
        body: JSON.stringify({
            "address": {
                "country": `${selectedAddress.context[3].short_code.toUpperCase()}`,
                "locality": `${selectedAddress.context[2].text}`,
                "postalCode": `${selectedAddress.context[0].text}`,
                "route": `${selectedAddress.text}`,
                "streetNumber": `${selectedAddress.address}`,
                "location": {"lat": selectedAddress.center[1], "lng": selectedAddress.center[0]},
            }
        })
    })

    if(res.status === 200){
        const locData = await res.json()

        const dataToUpdate = {
            user_id: id,
            residential_rent_micro_min: locData['residentialRent'].micro.min,
            residential_rent_micro_max: locData['residentialRent'].micro.max,
            residential_rent_micro_avg: locData['residentialRent'].micro.avg,
            residential_rent_macro_min: locData['residentialRent'].macro.min,
            residential_rent_macro_max: locData['residentialRent'].macro.max,
            residential_rent_macro_avg: locData['residentialRent'].macro.avg,
            residential_sale_micro_min: locData['residentialSale'].micro.min,
            residential_sale_micro_max: locData['residentialSale'].micro.max,
            residential_sale_micro_avg: locData['residentialSale'].micro.avg,
            residential_sale_macro_min: locData['residentialSale'].macro.min,
            residential_sale_macro_max: locData['residentialSale'].macro.max,
            residential_sale_macro_avg: locData['residentialSale'].macro.avg,
            office_micro_min: locData['office'].micro.min,
            office_micro_max: locData['office'].micro.max,
            office_micro_avg: locData['office'].micro.avg,
            office_macro_min: locData['office'].macro.min,
            office_macro_max: locData['office'].macro.max,
            office_macro_avg: locData['office'].macro.avg,
            retail_micro_min: locData['retail'].micro.min,
            retail_micro_max: locData['retail'].micro.max,
            retail_micro_avg: locData['retail'].micro.avg,
            retail_macro_min: locData['retail'].macro.min,
            retail_macro_max: locData['retail'].macro.max,
            retail_macro_avg: locData['retail'].macro.avg,
        }
        const [mlp_location, created] = await MLP_Location.upsert(dataToUpdate)
        return mlp_location.dataValues
    }
}

async function setMLPUnit(selectedAddress, id){
    let topics = ["residential-apartment-rent", "residential-apartment-sale", "residential-house-rent", "residential-house-sale", "office", "retail"]
    let fullArray = []

    for(let i = 0; i < topics.length; i++){
        const res = await fetch('https://api.21re.de/v3/prices/unit', {
            method: 'POST',
            headers: {
                'accept': 'application/json',
                'content-type': 'application/json',
                'authorization': 'Bearer J5P9OA6Q9LDDTG0EA10B6S8NU1CQ6J7K9G8TE9D6RLJ4042Q2GAJR37F',
                'Content-Type': 'application/json; charset=UTF-8'
            },
            body: JSON.stringify({
                "address": {
                    "country": `${selectedAddress.context[3].short_code.toUpperCase()}`,
                    "locality": `${selectedAddress.context[2].text}`,
                    "postalCode": `${selectedAddress.context[0].text}`,
                    "route": `${selectedAddress.text}`,
                    "streetNumber": `${selectedAddress.address}`,
                    "location": {"lat": selectedAddress.center[1], "lng": selectedAddress.center[0]},
                }, "unitType": `${topics[i]}`, "constructionYear": 2022, "area": 80, "exclusiveness": "standard"
            })
        })
        if (res.status === 200){
            const data = await res.json()
            fullArray.push({key: topics[i], data: data})
        }
    }
    if(fullArray.length === 6) {
        const residential_house_sale = fullArray.find( ({key}) => key === 'residential-house-sale')

        const residential_apartment_rent = fullArray.find( ({key}) => key === 'residential-apartment-rent')

        const residential_apartment_sale = fullArray.find( ({key}) => key === 'residential-apartment-sale')
        const office = fullArray.find( ({key}) => key === 'office')
        const retail = fullArray.find( ({key}) => key === 'retail')
        const residential_house_rent = fullArray.find( ({key}) => key === 'residential-house-rent')


        const dataToUpdate = {
            user_id: id,
            residential_house_sale_min: residential_house_sale.data.min,
            residential_house_sale_max: residential_house_sale.data.max,
            residential_house_sale_avg: residential_house_sale.data.avg,
            residential_apartment_rent_min: residential_apartment_rent.data.min,
            residential_apartment_rent_max: residential_apartment_rent.data.max,
            residential_apartment_rent_avg: residential_apartment_rent.data.avg,
            residential_apartment_sale_min: residential_apartment_sale.data.min,
            residential_apartment_sale_max: residential_apartment_sale.data.max,
            residential_apartment_sale_avg: residential_apartment_sale.data.avg,
            office_min: office.data.min,
            office_max: office.data.max,
            office_avg: office.data.avg,
            retail_min: retail.data.min,
            retail_max: retail.data.max,
            retail_avg: retail.data.avg,
            residential_house_rent_min: residential_house_rent.data.min,
            residential_house_rent_max: residential_house_rent.data.max,
            residential_house_rent_avg: residential_house_rent.data.avg,
        }

        const [mlp_unit, created] = await MLP_Unit.upsert(dataToUpdate)
        return mlp_unit.dataValues
    }

}

async function returnDBData(id){
    let AddressData = await Address.findAll({where:{user_id: id}})
    let CompareOffersData = await Compareable_Offers.findAll({where:{user_id: id}})
    let MacroData = await Macro.findAll({where:{user_id: id}})
    let MicroData = await Micro.findAll({where:{user_id: id}})
    let MLPLocationData = await MLP_Location.findAll({where:{user_id: id}})
    let MLPUnitData = await MLP_Unit.findAll({where:{user_id: id}})
    let MarketData = await Market.findAll({where:{user_id: id}})

    let MicroDataArray = []
    let MacroDataArray = []
    let CompareOffersArray = []
    let testMLP
    MicroData.map(e => {
        MicroDataArray.push(e.dataValues)
    })

    MacroData.map(e => {
        MacroDataArray.push(e.dataValues)
    })

    CompareOffersData.map(e => {
        CompareOffersArray.push(e.dataValues)
    })

    if(AddressData[0] !== undefined){
        AddressData = AddressData[0].dataValues
    }
    if(MLPUnitData[0] !== undefined){
        MLPUnitData = MLPUnitData[0].dataValues
    }
    if(MLPLocationData[0] !== undefined){
        MLPLocationData = MLPLocationData[0].dataValues
    }
    if(MarketData[0] !== undefined){
        MarketData = MarketData[0].dataValues
    }

    return {AddressData, CompareOffersArray, MacroDataArray, MicroDataArray, MLPLocationData, MLPUnitData, MarketData}
}

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
